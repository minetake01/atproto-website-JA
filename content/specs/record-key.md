---
title: レコードキー
summary: コレクション内の個々のレコードを識別するための識別子
---

# レコードキー

**レコードキー**（時折 `rkey` と略される）は、atprotoリポジトリ内の同じコレクション内の個々のレコードを命名および参照するために使用されます。これはAT URIのセグメントとして終わり、リポジトリMSTパスにもなります。

いくつか異なるレコードキーの命名スキームがサポートされています。すべてのレコードLexiconスキーマは、レコードコレクションのニーズとセマンティクスに応じてどのレコードキータイプを使用するかを示します。


### レコードキータイプ: `tid`

これは最も一般的なレコード命名スキームです。`TID` は「タイムスタンプ識別子」の略であり、名前はレコードの作成時刻から派生しています。

TIDの特徴は次のとおりです：

- 64ビット整数
- ビッグエンディアンバイトオーダリング
- `base32-sortable` としてエンコードされます。これは、文字 `234567abcdefghijklmnopqrstuvwxyz` でエンコードされ、パディングなしで13文字のASCII文字を生成します。
- ハイフンはTIDに含めてはいけません（以前のスキームのように）

64ビット整数のレイアウトは次のとおりです：

- 上位ビットは常に0
- 次の53ビットはUNIXエポックからのマイクロ秒を表します。53ビットは、JavaScriptで使用される64ビット浮動小数点数の最大安全整数精度として選択されています。
- 最後の10ビットはランダムな「クロック識別子」です。

TIDジェネレータはランダムなクロック識別子番号を生成する必要があります。これはできるだけ衝突を回避するように選択されます（たとえば、PDSサービスクラスタの複数のワーカーインスタンス間で）。ローカルクロックはタイムスタンプ自体を生成するために使用できます。TID出力ストリームが単調に増加し、同じマイクロ秒に複数のTIDが生成された場合や「クロックスミア」またはクロック同期のインシデント中にも二重にならないようにするために注意が必要です。ローカルクロックがミリ秒の精度しかない場合は、タイムスタンプをパディングする必要があります（これは1000倍することで行えます）。

TIDスキームの主な動機は、レコードの緩やかな時系列の順序付けを提供し、リポジトリデータ構造（MST）のストレージ効率を向上させることです。

注意: ["スノーフレーク識別子"](https://en.wikipedia.org/wiki/Snowflake_ID) との類似点があります。atprotoの分散コンテキストでは、TIDのグローバルな一意性は保証できず、敵対的なリポジトリコントローラーは既知のTIDを再利用してレコードを簡単に作成できます。


### レコードキータイプ: `literal:<value>`

このキータイプは、コレクション内に単一のレコードしかない場合に使用されます。固定された、よく知られたレコードキーが存在します。

最も一般的な値は `self` であり、Lexiconスキーマでは `literal:self` として指定されます。


### レコードキータイプ: `any`

全般的なレコードキーのスキーマ要件（以下参照）を満たす任意の文字列が許可されています。これは最も柔軟なレコードキータイプです。

これを使用して名前にセマンティクスをエンコードすることができます。たとえば、ドメイン名、整数、または（変換された）AT URIなど。これにより、重複の削減と既知のURIの検索が可能になります。


### レコードキーシンタックス

タイプに関係なく、レコードキーはいくつかの基本的な構文制約を満たす必要があります：

- ASCII文字のサブセットに制限されています。許可されている文字は英数字（`A-Za-z0-9`）、ピリオド、ダッシュ、アンダースコア、またはチルダ（`.-_~`）です。
- 少なくとも1文字、最大512文字である必要があります。
- 特定のレコードキーの値 `. `および `..` は許可されていません。
- リポジトリMSTパス文字列の許容可能な部分である必要があります（上記の制約でこの条件を満たしています）。
- URIのパスコンポーネントに含めることができる必要があります（RFC-3986、セクション3.3に従う）。上記の制約は、一般的なURIパスで許可されている「未予約」の文字に一致しています。

レコードキーは大文字と小文字を区別します。


### 例

有効なレコードキー：

```
3jui7kd54zh2y
self
example.com
~1.2-3_
dHJ1ZQ
```

無効なレコードキー：

```
literal:self
alpha/beta
.
..
#extra
@handle
any space
any+space
number[3]
number(3)
"quote"
pre:fix
dHJ1ZQ==
```

### 使用および実装ガイドライン

実装はTIDのグローバルな一意性に依存すべきではなく、TIDタイムスタンプを実際のレコード作成タイムスタンプとして信頼すべきではありません。レコードキーは「ユーザー制御のデータ」であり、敵対的なアカウントによって任意に選択される可能性があります。

ほとんどのリポジトリとレコードを処理するソフトウェアは、通常、レコードキータイプと値に対して無知であり、通常はそれらを単純な文字列として扱います。たとえば、TIDキーが`base32`にデコードされてユニークな`uint64`に変換されることを期待していると、これをデータベースキーとして使用することは鍵フォーマットの変更に強くなく、推奨されません。

リポジトリのコンテキストでは、同じレコードキーの値が複数のコレクションで使用される可能性があります。タプル `(did, rkey)` は一意ではなく、タプル `(did, collection, rkey)` が一意です。

ベストプラクティスとして、ほとんどの状況でキーパスを80文字未満に保つことが重要です。

コロン文字（`:`）は現在許可されていないことに注意してください。これはDIDをキーに含めることができないことを意味します。文字の変換なしに。

レコードキーは大文字と小文字を区別しますが、混乱を避け、大文字小文字を区別しないコンテキストでの再利用を最大化するためにすべて小文字のレコードキーを使用することを推奨します。


### 可能性のある将来の変更

将来的には、レコードキー構文の制約が緩和され、非ASCII Unicode文字を許可するかもしれません。レコードキーは常に有効なUnicodeであり、任意のバイトストリングを許可することはありません。

追加のレコードキータイプが定義されるかもしれません。

最大長さは微調整されるかもしれません。

`%`文字はURLエンコードに使用する可能性がありますが、現在そのようなエンコードはサポートされていません。

一般的な構文に関する追加の制約が追加される可能性があります。たとえば、少なくとも1つの英数字が必要など。