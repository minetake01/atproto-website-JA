---
title: イベントストリーム
summary: Lexiconオブジェクトのストリームにサブスクライブするためのネットワークワイヤープロトコル
wip: true
---

# イベントストリーム

通常の [HTTP API](/specs/xrpc) エンドポイントに加えて、atprotoは連続したイベントストリームをサポートしています。メッセージスキーマとエンドポイントの名前はトランスポートに依存せず、[Lexicons](/specs/lexicon) で定義されています。初期のエンコーディングとトランスポートスキームでは、バイナリの [DAG-CBOR](https://ipld.io/docs/codecs/known/dag-cbor/) エンコーディングが [WebSockets](https://en.wikipedia.org/wiki/WebSocket) を介して使用されます。

ストリームのLexiconタイプは `subscription` です。スキーマにはエンドポイントの識別子 (`id`)、`message` スキーマ（通常はユニオンで、複数のメッセージタイプを許可）、およびエラータイプのリスト (`errors`) が含まれます。

クライアントは指定されたエンドポイントで接続を開始することで特定のストリームにサブスクライブします。現在、ストリームは一方通行で、メッセージはサーバからクライアントに流れます。クライアントは接続を開く際にストリームを構成するためのクエリパラメータを提供できます。

**バックフィルウィンドウ**メカニズムを使用すると、クライアントは逃したかもしれないストリームメッセージに追いつくことができます。これは、ストリームイベントに単調に増加するシーケンス番号を割り当て、クライアントが接続を開始するときに初期のシーケンス番号を指定できるようにすることで高レベルで機能します。このメカニズムの目的は、合理的な時間ウィンドウ（例：数時間または数日）内において、イベントの信頼性のある配信を確保することです。これはクライアントがストリームの最初に戻ることを可能にするものではありません。

`com.atproto` ネームスペースの初期サブスクリプションLexiconはすべてバックフィルメカニズムを使用しています。ただし、ストリームに信頼性のある配信が必要でないサブスクリプションエンドポイントは、バックフィルメカニズムを実装する必要はありませんし、シーケンス番号を使用する必要もありません。

初期のサブスクリプションエンドポイントは公開されており、事前の許可や認証は必要ありません（ただし、クライアントにはリソース制限が課せられるかもしれません）。ただし、サブスクリプションエンドポイントでは接続時に既存のHTTP API（XRPC）認証メソッドを使用して認証が必要な場合があります。


## ストリーミングワイヤープロトコル（v0）

要約すると、メッセージはDAG-CBORとしてエンコードされ、バイナリのWebSocketを介して送信されます。クライアントはクエリパラメータを使用して特定のHTTPエンドポイントに接続し、次にWebSocketにアップグレードします。各WebSocketフレームには2つのDAG-CBORオブジェクトが含まれ、バイトが連結されます：ヘッダ（メッセージタイプを示す）と実際のメッセージ。

WebSocketsの "living standard" は現在、[WHATWG](https://en.wikipedia.org/wiki/WHATWG) によってメンテナンスされており、完全な仕様は [https://websockets.spec.whatwg.org/](https://websockets.spec.whatwg.org/) で確認できます。

### 接続

クライアントはHTTP接続を開始し、WebSocketにアップグレードしてストリームにサブスクライブを初期化します。インターネット上でのすべての接続には、デフォルトポート（443）での `wss://` を使用する必要があります。HTTP、クリアテキストWebSocket (`ws://`)、および非標準のポートは、テスト、開発、およびローカル接続（たとえばSSLを実装したリバースプロキシの背後）にのみ使用するべきです。クライアントの視点から、接続をWebSocketにアップグレードできない場合はエラーです。

クエリパラメータは、エンドポイントのLexiconスキーマで指定されたアプリケーション固有の方法でストリームを構成するために、初期のHTTPリクエストに提供できます。

エラーは通常、ストリーム自体を介して返されます。接続時のエラーはストリーム上の最初のメッセージとして送信され、次にサーバは接続を切断します。ただし、一部のエラーはストリームを介して処理できず、HTTPエラーとして返されます。

- `405 Method Not Allowed`: ストリームエンドポイントへの非GET HTTPリクエストに対してクライアントに返されます。
- `426 Upgrade Required`: ストリームエンドポイントへのリクエストに `Upgrade` ヘッダが含まれていない場合、クライアントに返されます。
- `429 Too Many Requests`: 頻繁に使用されるレート制限のために返されます。クライアントは遅延後に再試行できます。 `Retry-After` ヘッダのサポートが奨励されています。
- `500 Internal Server Error`: クライアントは遅延後に再試行できます。
- `501 Not Implemented`: サービスはWebSocketsまたはストリームを実装していない、少なくともこのエンドポイントではありません。クライアントは再試行すべきではありません。
- `502 Bad Gateway`, `503 Service Unavailable`, `504 Gateway Timeout`: クライアントは遅延後に再試行できます。

これらのステータスコードに対して、サーバは標準のXRPCエラーメッセージスキーマを使用してHTTPボディをJSONとして返すべきです。ただし、クライアントは予期せぬ応答ボディの形式にも堅牢である必要があります。定期的または計画的なダウンタイム中にデフォルトのロードバランサーまたはリバースプロキシエラーページを受信することは一般的な状況です。

サーバまたはクライアントは、一定の時間メッセージがない場合に開いているストリーム接続を切断することがあります。接続を無期限に開いておくことも許容されています。

### フレーミング

各バイナリWebSocketフレームには2つのDAG-CBORオブジェクトが含まれ、連結されます。最初のものは **ヘッダ** で、2番目は **ペイロード** です。

ヘッダDAG-CBORオブジェクトには次のフィールドがあります：

- `op` ("operation", integer, required): このフレームが何を含んでいるかを示す固定値
    - `1`: タイプが `t` によって指定される通常のメッセージ
    - `-1`: エラーメッセージ
- `t` ("type", string, optional): `op` が `1` の場合は必須。このメッセージのためのLexiconサブタイプを示す短い形式。フルLexicon識別子は含まれず、フラグメントのみです。例：`#commit`。 `op` が `-1` の場合、ヘッダには含めないでください。

クライアントは、未知の `op` または `t` 値を持つヘッダを無視するべきです。ヘッダとペイロードの両方の未知のフィールドは無視されるべきです。無効なフレーミングまたは無効なDAG-CBORエンコーディングは厳格なエラーであり、クライアントはフレームをスキップするのではなく、接続全体を切断すべきです。サーバはクライアントから受け取ったフレームを無視し、それをエラーとして扱うべきです。

エラーペイロードには常に次のフィールドが含まれます：

- `error` (string, required): エラータイプ名、ネームスペースや `#` 接頭辞なし
- `message` (string, optional): エラーの説明

エラーフレームの送受信後、ストリームは即座に閉じられるべきです。

メッセージペイロードは常にオブジェクトである必要があります。ヘッダで既にこの情報が示されているため、 `$type` フィールドは省略するべきです。atprotoではWebSocketフレームのサイズに特定の制限はありませんが、適度に小さく保つべきです（約数メガバイト程度）。

クライアントがメッセージのレートに追いつけない場合、サーバは "too slow" エラーを送信して接続を閉じることがあります。

### シーケンス番号

ストリームはオプションでメッセージごとのシーケンス番号を使用して信頼性を向上させることができます。クライアントは受信および正常に処理された最後のシーケンス番号を追跡し、再接続後にその番号を指定して逃したメッセージを受信できます。サーバは接続を超えてクライアントの状態を永続化しません。セマンティクスは [Apache Kafka](https://en.wikipedia.org/wiki/Apache_Kafka) のコンシューマーグループおよび他のストリーム処理プロトコルに類似しています。

サブスクリプションLexiconには `seq` フィールド（整数型）と `cursor` クエリパラメーター（整数型）を含める必要があります。すべてのメッセージタイプが `seq` を含める必要はありません。エラーは含めず、永続化されない `#info` メッセージタイプがあることが一般的です。

シーケンス番号は常に正の整数（ゼロでない）であり、単調に増加しますが、それ以外の柔軟なセマンティクスを持ちます。任意のギャップを含む可能性があります。たとえば、タイムスタンプである可能性があります。

JavaScriptで作業する際の混乱を防ぐために（デフォルトですべての数値を浮動小数点数として表すJavaScript）、シーケンス番号は64ビットフロートで安全に表現できる整数範囲に制限すべきです。つまり、整数範囲 `1` から `2^53` まで（上限を含まず）です。

カーソルとシーケンス番号の接続時のルール：

- `cursor` が指定されていない場合：サーバは現在のストリーム位置から送信を開始します。
- `cursor` が現在の `seq` よりも大きい（"未来"）場合：サーバはエラーメッセージを送信して接続を閉じます。
- `cursor` がロールバックウィンドウ内にある場合：サーバは `seq` 番号が大きいまたは等しい任意の永続化されたメッセージを送信し、現在のストリームに追いついたら続行します。
- `cursor` がロールバックウィンドウよりも古い場合：ストリーム内の最初のメッセージは、`cursor` が古すぎると示すinfoであり、次に利用可能な最も古い `seq` から始まり、整个のロールバックウィンドウを送信し、次に現在のストリームを続行します。
- `cursor` が `0` の場合：サーバは利用可能な最も古い `seq` から始まり、整个のロールバックウィンドウを送信し、次に現在のストリームを続行します。

シーケンス番号の範囲はサービスプロバイダー（ホスト名）とエンドポイント（NSID）の組み合わせです。これは通常、接続に使用される `wss://` URL に対応します。つまり、シーケンス番号は同じサービス上の異なるストリームエンドポイント間で一意であるかどうかが異なるかもしれません。

サービスは通常、シーケンス番号が再利用されないようにする必要があります。これは通常、イベント（シーケンス番号付き）を頑丈な永続ストレージにコミットする前にストリームを通じて送信することによって実現されます。

いくつかの壊滅的な障害モード（またはインフラストラクチャの大きな変更）では、サーバがバックフィルウィンドウのデータを失い、シーケンス番号を `1` にリセットする必要がある可能性があります。この場合、クライアントがより高い番号で再接続すると、サーバはクライアントに `FutureCursor` エラーを返します。クライアントはこれらのシナリオでどの戦略を採用するかを決定する必要があります。通常、クライアントは順序外または重複したシーケンス番号をエラーとして扱い、メッセージを処理せずに接続を切断すべきです。ほとんどのクライアントは、人間のオペレータの介入なしにシーケンス状態をリセットすべきではありませんが、これはストリーム内のすべてのイベントの信頼性のある配信が不要な一部の一時的なクライアントにとっては合理的な動作かもしれません。

## 使用および実装ガイドライン

現在のストリームトランスポートは主にサーバー間データ同期のために設計されています。Webアプリケーションがエンドユーザーブラウザから直接接続することも可能ですが、バイナリフレームとDAG-CBORのデコードは非常に難しいことに注意してください。

HTTPリダイレクトとWebSocketのアップグレードの組み合わせは、WebSocketクライアントライブラリで一貫してサポートされていません。atprotoでは明示的に必要または禁止されていません。

atprotoによってWebSockets標準のサポートされているバージョンは指定されていません。現在の安定したWebSocket標準はバージョン13です。実装は、モダンなバージョンをサポートする合理的な努力をし、ある程度の後方互換性を保持するべきです。

WebSocketsには明確なリソースの制限とサービス妨害の問題があります。ネットワーク帯域幅の制限とスロットリングは、サーバーとクライアントの両方に推奨されています。サーバーは同時接続制限とバッファサイズを調整して、リソース枯渇を防ぐべきです。

サービスがシーケンスの状態をリセットする必要がある場合、新しい初期シーケンス番号を前のシーケンス番号よりも健全な余裕を持って選択することが推奨されています。たとえば、永続的なストレージの損失後、または前のストリーム状態をクリアする場合です。

特定のホストのストリームエンドポイントを参照するURLは、通常`wss://`をURIスキームとして使用するべきです（`https://`ではなく）。

## セキュリティとプライバシーの考慮事項

"接続"セクションで述べたように、インターネット上のストリーム接続には`wss://`（SSL）のみを使用すべきです。公共サービスは非SSL接続を拒否すべきです。

ほとんどのHTTP XRPCエンドポイントはJSON形式のコンテンツで動作しますが、ストリームエンドポイントは信頼できない入力として直接DAG-CBORオブジェクトで動作します。敵対的なデータエンコーディングとデータ構造の操作に対する注意が必要です。具体的な問題は[データモデル](/specs/data-model)および[リポジトリ](/specs/repository)の仕様で議論されています。

## 可能な将来の変更

イベントストリームはATプロトコルの最新のコンポーネントの一つであり、詳細は他のコンポーネントと比較して反復される可能性が高いです。

シーケンス番号のスキームは、シャーディングされたストリームをより効果的にサポートするために調整されるかもしれません。その動機は、複数の接続を介して公共インターネット上でより高いデータスループットを処理することです。

追加のトランスポート（WebSocket以外）およびエンコーディング（DAG-CBOR以外）が指定される可能性があります。たとえば、ブラウザでのデコードが簡単なテキストWebSocketフレーム内のJSONペイロードです。

追加のWebSocketの機能が採用されるかもしれません：

- トランスポート圧縮の「拡張機能」、`permessage-deflate`のようなもの
- サブプロトコルの定義
- 双方向メッセージング
- 1000クラスの応答コード

この仕様書の曖昧な点は解決されるか、または開かれるかもしれません。例：

- HTTPリダイレクト
- ブラウザ接続のCORSおよびその他の問題
- メッセージ/フレームの最大サイズ

通常のHTTP XRPCエンドポイントと同様に、認証スキームがサポートされるかもしれません。