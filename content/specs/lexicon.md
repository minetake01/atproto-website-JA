---
title: レキシコン
summary: スキーマ定義言語。
---

# レキシコン

レキシコンは、atprotoのレコード、HTTPエンドポイント（XRPC）、およびイベントストリームメッセージを記述するために使用されるスキーマ定義言語です。これは、atproto [データモデル](/specs/data-model)の上に構築されています。

このスキーマ言語は、[JSON Schema](http://json-schema.org/)と[OpenAPI](https://en.wikipedia.org/wiki/OpenAPI_Specification)に類似していますが、atproto固有の機能とセマンティクスが含まれています。

この仕様書は、レキシコン定義言語のバージョン1を説明しています。

## タイプの概要

| レキシコン タイプ | データモデル タイプ | カテゴリ |
| --- | --- | --- |
| `null` | Null | 具体的 |
| `boolean` | Boolean | 具体的 |
| `integer` | Integer | 具体的 |
| `string` | String | 具体的 |
| `bytes` | Bytes | 具体的 |
| `cid-link` | Link | 具体的 |
| `blob` | Blob | 具体的 |
| `array` | Array | コンテナ |
| `object` | Object | コンテナ |
| `params` |  | コンテナ |
| `token` |  | メタ |
| `ref` |  | メタ |
| `union` |  | メタ |
| `unknown` |  | メタ |
| `record` |  | プライマリ |
| `query` |  | プライマリ |
| `procedure` |  | プライマリ |
| `subscription` |  | プライマリ |

## レキシコン ファイル

レキシコンは単一のNSIDに関連付けられたJSONファイルです。ファイルには1つ以上の定義が含まれ、それぞれが異なる短い名前を持ちます。名前が `main` の定義は、オプションでファイル全体の「プライマリ」定義を記述します。定義がゼロの場合、レキシコンは無効です。

レキシコンJSONファイルは次のフィールドを持つオブジェクトです：

- `lexicon`（整数、必須）：レキシコン言語のバージョンを示します。このバージョンでは、`1` の固定値です。
- `id`（文字列、必須）：レキシコンのNSID
- `revision`（整数、オプション）：このレキシコンのバージョンを示します。変更がある場合にのみ指定します。
- `description`（文字列、オプション）：レキシコンの簡単な概要。通常は1、2文程度です。
- `defs`（文字列からオブジェクトへのマップ、必須）：異なる名前（キー）を持つ一連の定義

`defs` の下のスキーマ定義には、タイプを区別するための `type` フィールドがあります。ファイルには最大で1つの「プライマリ」タイプの定義が含まれることができます。プライマリタイプは常に `main` という名前を持つべきです。ただし、`main` が非プライマリタイプを記述することも可能です。

レキシコン内の特定の定義への参照は、フラグメント構文を使用して行います（例：`com.example.defs#someView`）。`main` 定義が存在する場合、フラグメントなしでNSIDを使用して参照できます。データオブジェクト自体の `$type` フィールド内での参照（たとえば、レコードまたはユニオンのコンテンツ）では、これが「必須」です（`#main` サフィックスの使用は無効です）。たとえば、`com.example.record` ではなく、`com.example.record#main`。

`revision` フィールドのセマンティクスはまだ確定していませんが、これは第三者が複数のバージョンやコピーの中で最新のものを識別するのに役立つことを意図しています。

関連するレキシコンは、通常はNSID階層内でまとめられます。慣例として、複数のレキシコンで使用される定義は、グループ内の専用の `*.defs` レキシコン（例：`com.atproto.server.defs`）で定義されます。`*.defs` レキシコンには一般的に `main` という名前の定義を含めない方が良いですが、厳密には無効ではありません。

## プライマリ タイプの定義

プライマリタイプは次のとおりです：

- `query`：XRPC Query（HTTP GET）を説明します。
- `procedure`：XRPC Procedure（HTTP POST）を説明します。
- `subscription`：イベントストリーム（WebSocket）
- `record`：リポジトリレコードに保存できるオブジェクトを記述します。

各プライマリ定義スキーマオブジェクトには、次のフィールドが含まれます：

- `type`（文字列、必須）：タイプの値（例：レコードの場合は `record`）
- `description`（文字列、オプション）：簡単で通常1、2文の説明

### レコード

タイプ固有のフィールド：

- `key`（文字列、必須）：[Record Key タイプ](/specs/record-key) を指定します。
- `record`（オブジェクト、必須）：このレコードのタイプを指定する `object` タイプのスキーマ定義

### クエリおよび手順（HTTP API）

タイプ固有のフィールド：

- `parameters`（オブジェクト、オプション）：このエンドポイントのHTTPクエリパラメータを記述する `params` タイプのスキーマ定義
- `output`（オブジェクト、オプション）：HTTPレスポンスボディを記述します
    - `description`（文字列、オプション）：簡単な説明
    - `encoding`（文字列、必須）：ボディコンテンツのMIMEタイプ。JSONレスポンスの場合は `application/json` を使用します。
    - `schema`（オブジェクト、オプション）：スキーマ定義、`object`、`ref`、または `union` のいずれか。JSONエンコードされた応答を記述するために使用されますが、JSONレスポンスに対してもスキーマはオプションです。
- `input`（オブジェクト、オプション、`procedure` のみ）：HTTPリクエストボディのスキーマを記述します。フォーマットは `output` フィールドと同じです。
- `errors`（オブジェクトの配列、オプション）：返される可能性のあるエラーコードのセット
    - `name`（文字列、必須）：エラータイプの短い名前、空白なし
    - `description`（文字列、オプション）：簡単な説明、1、2文

### 購読（イベントストリーム）

タイプ固有のフィールド：

- `parameters`（オブジェクト、オプション）: クエリと手続きと同じ
- `message`（オブジェクト、オプション）: どのメッセージが可能かを指定
    - `description`（文字列、オプション）: 簡単な説明
    - `schema`（オブジェクト、必須）: `union` の参照でなければならないスキーマ定義
- `errors`（オブジェクトの配列、オプション）: クエリと手続きと同じ

購読スキーマ（`message`の`schema`フィールドで参照されるもの）は、`object`タイプではなく、`union`のrefsである必要があります。

## フィールドタイプの定義

主な定義と同様に、すべてのスキーマオブジェクトにはこれらのフィールドが含まれます。

- `type`（文字列、必須）: 各タイプの固定値
- `description`（文字列、オプション）: 短い、通常は一文または二文だけ

### `null`

追加のフィールドはありません。

### `boolean`

タイプ固有のフィールド：

- `default`（ブール、オプション）: このフィールドのデフォルト値
- `const`（ブール、オプション）: このフィールドの固定（定数）値

HTTPクエリパラメータとして含まれる場合、`true`または`false`（クォートなし）にレンダリングされる必要があります。

### `integer`

符号付き整数。

タイプ固有のフィールド：

- `minimum`（整数、オプション）: 最小許容値
- `maximum`（整数、オプション）: 最大許容値
- `enum`（整数の配列、オプション）: 許容される値のクローズドセット
- `default`（整数、オプション）: このフィールドのデフォルト値
- `const`（整数、オプション）: このフィールドの固定（定数）値

### `string`

タイプ固有のフィールド：

- `format`（文字列、オプション）: 文字列のフォーマット制約
- `maxLength`（整数、オプション）: 値の最大長、UTF-8バイト単位
- `minLength`（整数、オプション）: 値の最小長、UTF-8バイト単位
- `maxGraphemes`（整数、オプション）: Unicode Grapheme Clustersとしてカウントされる場合の値の最大長
- `minGraphemes`（整数、オプション）: Unicode Grapheme Clustersとしてカウントされる場合の値の最小長
- `knownValues`（文字列の配列、オプション）: このフィールドの提案または共通の値のセット。値はこのセットに限定されない（つまりクローズドenumではない）。
- `enum`（文字列の配列、オプション）: 許容される値のクローズドセット
- `default`（文字列、オプション）: このフィールドのデフォルト値
- `const`（文字列、オプション）: このフィールドの固定（定数）値

文字列はUnicodeです。非Unicodeエンコーディングの場合は、代わりに`bytes`を使用してください。基本的な`minLength`/`maxLength`の検証制約はUTF-8バイトとして数えられます。JavaScriptはデフォルトでUTF-16で文字列を保存するため、正確に数えるには再エンコードが必要です。`minGraphemes`/`maxGraphemes`の検証制約はGrapheme Clustersで機能し、これは技術的および言語的に複雑な定義を持っていますが、ルーズには「異なる視覚的な文字」に対応します。これにはラテン文字、CJK文字、句読点、数字、または絵文字などが含まれる可能性があります（これは複数のUnicodeコードポイントと多くのUTF-8バイトで構成されるかもしれません）。

`format`は文字列のフォーマットを制約し、追加の意味論的コンテキストを提供します。使用可能なフォーマットタイプとそれらの定義については、Data Model仕様を参照してください。

`const`と`default`は互換性がありません。

### `bytes`

タイプ固有のフィールド：

- `minLength`（整数、オプション）: エンコーディングのない生のバイトの値の最小サイズ
- `maxLength`（整数、オプション）: エンコーディングのない生のバイトの値の最大サイズ

### `cid-link`

タイプ固有のフィールドはありません。

CIDの制約については[Data Model仕様](/specs/data-model

)を参照してください。

### `array`

タイプ固有のフィールド：

- `items`（オブジェクト、必須）: この配列のスキーマ要素を説明
- `minLength`（整数、オプション）: 配列内の要素の最小数
- `maxLength`（整数、オプション）: 配列内の要素の最大数

理論的には、配列は均質な型を持つはずです（つまり、すべての要素が同じ型を持つという意味）。ただし、共用型の場合、この制約は無意味であるため、実装はすべての要素が同じ型であるとは仮定できません。

### `object`

他の定義内で参照されることができる一般的なオブジェクトスキーマ。

タイプ固有のフィールド：

- `properties`（文字列からオブジェクトへのマップ、必須）: 名前ごとに定義されたプロパティ（フィールド）
- `required`（文字列の配列、オプション）: 必要なプロパティを示します
- `nullable`（文字列の配列、オプション）: 値として`null`を持つことができるプロパティを示します

データモデル仕様に記載されているように、フィールドを省略することと、`null`の値を持つフィールドを含むこと、および「false-y」な値（`false`、`0`、空の配列など）を含むことの間にはセマンティックな違いがあります。

### `blob`

タイプ固有のフィールド：

- `accept`（文字列の配列、オプション）: 受け入れ可能なMIMEタイプのリスト。各タイプはグロブパターンとして`*`で終わる場合があります（例: `image/*`）。どのMIMEタイプも受け入れる場合は`*/*`を使用します。
- `maxSize`（整数、オプション）: バイト単位での最大サイズ

### `params`

これは限定されたスコープのタイプであり、`query`、`procedure`、および`subscription`の主要なタイプの`parameters`フィールドでのみ使用されます。これらはHTTPクエリパラメータにマップされます。

タイプ固有のフィールド：

- `required`（文字列の配列、オプション）：`object`のフィールドと同じセマンティクス
- `properties`：`object`の下のプロパティと似ていますが、`boolean`、`integer`、`string`、および`unknown`のタイプのいずれか、またはこれらのタイプのいずれかの`array`のみを含めることができます。

`params`には`object`とは異なり、`nullable`フィールドはありません。

### `token`

トークンは名前で参照されるだけの空のデータ値です。特定の意味を持つ値のセットを定義するために使用されます。 `description` フィールドはトークンの意味を明確にする必要があります。

トークンは一部のプログラミング言語の「シンボル」の概念に類似しており、文字列、変数、組み込みのキーワード、または他の識別子とは異なります。

例えば、トークンはエンティティの状態（ステートマシン内の）、またはカテゴリのリストを列挙するために定義される可能性があります。

タイプ固有のフィールドはありません。

### `ref`

タイプ固有のフィールド：

- `ref`（文字列、必須）：別のスキーマ定義への参照

`ref`は、スキーマ定義を複数の場所で再利用するための仕組みです。`ref`文字列は、Lexiconタイプ定義（NSIDであることもあり、オプションで`main`以外の定義を示す`#`で区切られた名前を含む）へのグローバルな参照であるか、同じLexiconファイル内のローカルな定義を示すことができます（`#`の後に名前が続きます）。

### `union`

タイプ固有のフィールド：

- `refs`（文字列の配列、必須）：スキーマ定義への参照
- `closed`（ブール、オプション）：unionが「オープン」または「クローズド」かを示します。デフォルトは`false`（オープンunion）

Unionは、スキーマ内のこの場所に複数の可能なタイプが存在することを示します。参照は`ref`と同じ構文を使用し、グローバルまたはローカルのスキーマ定義の両方を参照できます。実際のデータは単一の特定のタイプに対して検証されます：unionは複数のスキーマからフィールドを*組み合わせない*か、新しい*ハイブリッド*データタイプを定義しません。異なるタイプは **variants** と呼ばれます。

デフォルトでは、unionは「オープン」であり、将来のスキーマの改訂で参照リストにさらなるタイプを追加できます（タイプを削除することはできません）。これは、実装がLexiconの最新バージョンを持っていない場合に対応するために、検証時に寛容であるべきであることを意味します。`closed`フラグ（ブール）は、タイプのセットが固定され、将来に拡張できないことを示すことができます。

`refs`がない`union`スキーマ定義は、`unknown`と同様に許可されます（デフォルトでは`closed`フラグがfalseである限り）。 `closed`をtrueに設定した空のrefsリストは無効なスキーマです。

`union`によって指定されたスキーマは一般的にはオブジェクトまたはオブジェクトに明確なマッピングを持つタイプで、 `record` のようなものです。すべてのバリアントはCBORマップ（またはJSONオブジェクト）によって表現され、バリアントタイプを示す `$type` フィールドを含める必要があります。

### `unknown`

この場所には特定の検証がないまま、任意のデータが表示されることを示します。ただし、データはデータモデルの下で依然として有効でなければなりません。これは、浮動小数点などのサポートされていないものを含むことはできません。

タイプ固有のフィールドはありません。

## 文字列フォーマット

文字列はオプションで次の`format`タイプのいずれかに制約されることがあります。

- `at-identifier`：[Handle](/specs/handle)または[DID](/specs/did)のいずれか、詳細は以下に記載
- `at-uri`：[AT-URI](/specs/at-uri-scheme)
- `cid`：文字列形式のCID、データモデルで指定された詳細
- `datetime`：タイムスタンプ、以下に指定された詳細
- `did`：汎用[DID Identifier](/specs/did)
- `handle`：[Handle Identifier](/specs/handle)
- `nsid`：[Namespaced Identifier](/specs/nsid)
- `uri`：汎用URI、以下に指定された詳細
- `language`：言語コード、以下に指定された詳細

さまざまな識別子フォーマットの場合、Lexiconスキーマ検証時に最も広範な識別子構文形式を許可するべきです。基本的な構文検証をパスしない識別子に関する問題は、レキシコンデータ検証エラーではなく、アプリケーションエラーとして報告する必要があります。例えば、`did`フォーマットの文字列フィールドにはどの種類のDIDメソッドも含まれていないデータは、アプリケーションエラーとして別個に発生すべきです。

### `at-identifier`

これは、DID（type: did）またはハンドル（handle）である文字列型です。主にXRPCクエリパラメータで使用されます。at-identifierがハンドルまたはDIDであるかどうかは明確です。なぜなら、DIDは常にdid:で始まり、コロン文字（：）はハンドルでは許可されていないからです。

### `datetime`

タイムゾーン情報を含むフルプレシジョンの日時です。

この形式は、現代のコンピューティング時代（UNIXエポック以降）のコンピュータ生成のタイムスタンプとの使用を意図しています。歴史的なイベント、曖昧さ、または遠い未来の時間を表す場合は、異なる形式が適している可能性があります。現在の時代（ゼロ年）以前の日時は特に許可されていません。

日時形式の標準は非常に柔軟で重複しています。atprotoの日時文字列は[RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)、[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)、および[WHATWG HTML](https://html.spec.whatwg.org/#dates-and-times)の日時標準の**交差する**要件を満たす必要があります。

「日付」と「時間」の部分を分離する文字は大文字の `T` である必要があります。

タイムゾーンの指定が必要です。UTCタイムゾーンを使用し、タイムゾーンを単純な大文字の `Z` 接尾辞で表現することが*強く*推奨されています（小文字は許可されていません）。時間/分接尾辞構文（`+01:00`や`-10:30`のような）がサポートされていますが、「負のゼロ」（`-00:00`）は明示的に許可されていません（ISO 8601による）。

全秒の精度が必要であり、任意の小数点以下の精度桁が許可されています。ベストプラクティスは、少なくともミリ秒の精度を使用し、生成された精度にゼロをパディングすることです（例：`12.340Z`の代わりに`12.34Z`の後にゼロを追加）。すべての日時フォーマットライブラリが末尾のゼロのフォーマットをサポートしているわけではありません。ミリ秒およびマイクロ秒の精度は合理的なクロスランゲージサポートを持っていますが、ナノ秒の精度はありません。

実装は、日時の往復時に生じる2つの曖昧さに注意する必要があります：精度の低下と末尾の小数秒ゼロの曖昧さ。Lexiconレコードをネイティブなタイプに逆シリアル化してから再シリアル化する場合、文字列表現が同じでない可能性があり、破損したハッシュ参照、正当性チェックの失敗、またはリポジトリの更新の過剰が発生する可能性があります。安全な方法は、日時を単純な文字列として逆シリアル化することで、往復の再シリアル化を確実にします。

実装は日時のセマンティクスが有効であることを検証すべきです（例：月や日が`00`の場合は無効です）。

有効な例：

```text
# 推奨
1985-04-12T23:20:50.123Z
1985-04-12T23:20:50.123456Z
1985-04-12T23:20:50.120Z
1985-04-12T23:20:50.120000Z

# サポートされている
1985-04-12T23:20:50.12345678912345Z
1985-04-12T23:20:50Z
1985-04-12T23:20:50.0Z
1985-04-12T23:20:50.123+00:00
1985-04-12T23:20:50.123-07:00
```

無効な例：

```text
1985-04-12
1985-04-12T23:20Z
1985-04-12T23:20:5Z
1985-04-12T23:20:50.123
+001985-04-12T23:20:50.123Z
23:20:50.123Z
-1985-04-12T23:20:50.123Z
1985-4-12T23:20:50.123Z
01985-04-12T23:20:50.123Z
1985-04-12T23:20:50.123+00
1985-04-12T23:20:50.123+0000

# ISO-8601 strict capitalization
1985-04-12t23:20:50.123Z
1985-04-12T23:20:50.123z

# RFC-3339, but not ISO-8601
1985-04-12T23:20:50.123-00:00
1985-04-12 23:20:50.123Z

# タイムゾーンが必要です
1985-04-12T23:20:50.123

# 構文は正常に見えるが、日時は無効です
1985-04-12T23:99:50.123Z
1985-00-12T23:20:50.123Z
```

### `uri`

任意のURIスキーマに柔軟に対応し、URIに関する汎用RFC-3986に従います。これには、`did`、`https`、`wss`、`ipfs`（CID用）、`dns`、そしてもちろん`at`などが含まれます。Lexicons内の最大長は8 KBytesです。

### `language`

[IETF言語タグ](https://en.wikipedia.org/wiki/IETF_language_tag)文字列で、[BCP 47](https://www.rfc-editor.org/info/bcp47)に準拠し、[RFC 5646](https://www.rfc-editor.org/rfc/rfc5646.txt)（"Tags for Identifying Languages"）で定義されています。これはHTTP、HTML、および他のWeb標準で言語を識別するために使用される標準です。Lexicon文字列はRFCで定義されているように "well-formed" 言語タグとして検証する必要があります。クライアントはRFCによれば "well-formed" であるが RFCによって "valid" でない言語文字列を無視すべきです。

RFCで指定されているように、ISO 639の2文字および3文字の言語コードは単独で、小文字で使用できます。例として、`ja`（日本語）や`ban`（バリ語）などが挙げられます。地域サブタグを追加することもできます。例えば、`pt-BR`（ブラジルポルトガル語）です。また、`hy-Latn-IT-arevela`のように追加のサブタグも使用できます。

言語コードは一般的に解析、正規化、および意味的な一致が必要であり、単純な文字列比較ではありません。例えば、検索エンジンは言語タグをISO 639コードに簡略化してインデックス化およびフィルタリングに使用するかもしれませんが、クライアントアプリケーション（ユーザーエージェント）は表示（テキストのレンダリング）のために完全な言語コードを保持するでしょう。

## `$type`の使用時

データオブジェクトには、そのLexiconタイプを示す `$type` フィールドが含まれることがあります。一般的な原則は、データを検証する際にコンテンツのタイプについて曖昧性がある場合、このフィールドを含める必要があるというものです。

具体的なルールは以下の通りです：

- `record` オブジェクトには常に `$type` を含める必要があります。タイプは通常コンテキストから判明しますが（たとえば、リポジトリに格納されたレコードのパスのコレクション部分など）、レコードオブジェクトはリポジトリの外でも渡され、自己記述する必要があります。
- `union` バリアントは常に `$type` を含める必要がありますが、`subscription` メッセージのトップレベルでは必要ありません。

`blob` オブジェクトは常に `$type` を含むため、汎用処理が可能です。

注意として、`main` タイプは `$type` フィールドに NSID のみを参照する必要があり、`#main` 接尾辞は含めません。

## Lexiconの進化

Lexiconsは時間の経過とともに変更が許可されており、前方と後方の互換性を確保するためにある程度の範囲内で変更できます。基本的な原則は、すべての古いデータは更新されたLexiconの下でまだ有効でなければならず、新しいデータは古いLexiconの下で有効でなければなりません。

- 任意の新しいフィールドはオプションである必要があります。
- 非オプションのフィールドは削除できません。ベストプラクティスとして、使用されなくなった場合はすべてのフィールドをLexiconに保持し、それらを非推奨とマークすることです。
- タイプは変更できません。
- フィールドの名前を変更できません。

より大きな破壊的な変更が必要な場合、新しいLexicon名を使用する必要があります。

Lexiconが公開され、"確定" されたと見なされる時点はあいまいです。最低限、公的な採用とサードパーティによる実装は、明示的な許可がなくてもLexiconがリリースされ、互換性を壊してはならないことを示唆します。ベストプラクティスとして、実験的または開発中のステータスをLexiconタイプ名に明示的に示すことです。例： `com.corp.experimental.newRecord`。

## 権威と制御

Lexiconの権限はNSIDによって決定され、ドメイン権限のDNS制御に根ざしています。その権限はLexiconの定義に対する最終的な制御を持ち、Lexiconスキーマの定義の維持と配布の責任があります。

危機の場合、たとえばDNS制御が悪意のあるアクターによって意図せず失われた場合、プロトコルエコシステムはこの権限連鎖を無視することを決定するかもしれません。これは例外的な状況でのみ行われるべきであり、アクティブな権威を逸脱するメカニズムとしてではありません。プロトコルの紛争を解決する主要なメカニズムは、新しい名前空間にLexiconをフォークすることです。

プロトコルの実装は、一般的にLexiconに対して検証に失敗したデータを完全に無効と見なすべきであり、データの個々の部分に対して修復や部分的な処理を試みるべきではありません。

それ以外のLexiconに準拠しているデータに予期しないフィールドが含まれている場合、これらは無視されるべきです。スキーマの検証時には、最悪の場合警告として扱われるべきです。これは、制御権限を持つ権威によるスキーマの進化と、古いLexiconの場合にも強固である必要があるためです。

第三者は技術的にはデータに任意の追加フィールドを挿入できます。これはアプリケーションを拡張するための推奨されない方法ですが、特に禁止されているわけではありません。これの危険性の一つは、Lexiconが同じフィールド名でも異なるタイプのフィールドを含むように更新される可能性があるため、既存のデータが無効になる可能性があることです。

## 使用と実装のガイドライン

LexiconスキーマをJSON SchemaやOpenAPIに変換し、それらのエコシステムのツールやライブラリを使用して、JSON形式のatprotoデータと連携できるようにすることが望ましいです。

JSONやCBORから特定のLexiconから派生した構造体にシリアライズおよびデシリアライズする実装は、予期しないフィールドの「clobbering」のリスクを認識する必要があります。たとえば、Lexiconが新しい（オプションの）フィールドを追加するように更新された場合、古い実装はそのフィールドを認識せず、デシリアライズおよび再シリアライズ時にデータを意図せず削除する可能性があります。コンテキストによっては、この問題を回避する方法として「余分な」フィールドを保持するか、元のデータオブジェクトを再シリアライズする代わりにそのまま渡す方法があります。

## 可能性のある将来の変更

予期しない追加フィールドの検証ルールは変更される可能性があります。例えば、スキーマが「閉じられていて予期しないフィールドは許可されない」と示すためのLexiconのメカニズム、または非公式な拡張を示すためのフィールド名接頭辞（`x-`）に関する慣習などが考えられます。
