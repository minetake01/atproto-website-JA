---
title: DID
summary: 永続的な分散型識別子（atprotoで使用されるもの）
---

# AT Protocol DIDs

AT Protocolは、[分散型識別子](https://en.wikipedia.org/wiki/Decentralized_identifier)（DID）を永続的で長期的なアカウント識別子として使用しています。DIDはW3Cの標準であり、多くの標準化されたおよび提案されたDIDメソッドの実装があります。

## 祝福されたDIDメソッド

現在、atprotoは2つのDIDメソッドをサポートしています：

- `did:web`は、HTTPS（およびDNS）に基づくW3C標準です。識別子セクションはホスト名です。このメソッドは、`did:plc`に対する独立した代替手段を提供するためにatprotoでサポートされています。このメソッドは使用されるドメイン名に固有であり、ドメイン名の制御の喪失からの移行や回復のメカニズムを提供しません。atprotoのコンテキストでは、ホスト名レベルの`did:web` DIDsのみがサポートされています。パスベースのDIDはサポートされていません。ハンドルに適用されるトップレベルドメインに関する同じ制限（例：`.arpa`を使用しない）が`did:web`ドメインにも適用されます。特別な`localhost`ホスト名は許可されていますが、テストおよび開発環境でのみです。ポート番号（区切りコロンは16進エンコード）は、`localhost`の場合のみ許可され、テストおよび開発環境でのみ使用されます。
- `did:plc`は、Blueskyによって開発された新しいDIDメソッドです。詳細については、[did-method-plc](https://github.com/did-method-plc/did-method-plc) GitHubリポジトリを参照してください。このメソッドは「プレースホルダー」と呼ばれていますが、無期限にサポートされます。

将来的には、追加のメソッドがサポートされるかもしれません。普遍的なリゾルバーソフトウェアの存在に関係なく、すべてまたは多くのDIDメソッドをサポートする意図はありません。

## AT Protocol DID識別子構文

語彙文字列の形式：`did`

DID識別子の構文制約は、使用されるメソッドにかかわらず、DIDコア仕様にあります。これらの構文制約の要約は、atprotoで一般的にDIDを検証するために使用できます：

- URI全体は、ASCIIのサブセットで構成され、大文字小文字を区別し、文字（`A-Z`、`a-z`）、数字（`0-9`）、ピリオド、アンダースコア、コロン、パーセント記号、またはハイフン（`._:%-`）を含みます。
- URIは大文字小文字を区別します。
- URIは小文字 `did:` で始まります。
- メソッドセグメントは、1つ以上の小文字の文字（`a-z`）に続いて `:` です。
- URIの残り部分（識別子）には、パーセント記号（`%`）を除く、上記で許可されたASCII文字が含まれていてもよいです。
- URI（およびしたがって残りの識別子）は `:` で終わってはいけません。
- パーセント記号（`%`）は識別子セクションで「パーセントエンコーディング」に使用され、常に2つの16進数の文字に続く必要があります。
- クエリ（`?`）およびフラグメント（`#`）セクションはDID URIで許可されていますが、DID識別子では許可されていません。atprotoのコンテキストでは、クエリとフラグメント部分は許可されていません。

DID識別子には一般的に最大長制限はありませんが、atprotoのコンテキストでは初期の硬い制限が2 KBあります。

atprotoのコンテキストでは、実装はパーセントエンコーディングを検証する必要はありません。パーセント記号はDID識別子セグメントで許可されていますが、識別子はパーセント記号で終わってはいけません。無効なパーセントエンコーディングを含むDIDは、登録、解決などの試みを失敗するはずです。

atprotoのコンテキストでは、DIDに対する合理的な出発点の正規表現は次の通りです：

```
// 注：全体の長さを制約しません
/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/
```

### 例

atprotoで使用するための有効なDID（正しい構文、およびサポートされているメソッド）：

```
did:plc:z72i7hdynmk6r22z27h6tvur
did:web:blueskyweb.xyz
```

DID構文が有効（Lexicon構文検証を通過する）、ただしサポートされていないDIDメソッド：

```
did:method:val:two
did:m:v
did:method::::val
did:method:-:_:.
did:key:zQ3shZc2QzApp2oymGvQbzP8eKheVshBHbU4ZYjeXqwSKEn6N
```

無効なDID識別子構文（DIDメソッドに関係なく）：

```
did:METHOD:val
did:m123:val
DID:method:val
did:method:
did:method:val/two
did:method:val?two
did:method:val#two
```

## DIDドキュメント

DIDドキュメントが解決された後、atproto固有の情報を抽出する必要があります。この解析プロセスはドキュメントを解決するために使用されるDIDメソッドに対して不可知です。

現在のDIDの**ハンドル**は `alsoKnownAs` 配列で見つかります。この配列の各要素はURIです。ハンドルはURIスキームが `at://` で始まり、パスや他のURIパーツはなく、現在のDIDドキュメントに一致するか確認するためにハンドルを解決することで、双方向に検証することが重要です。

DIDは主要なアカウント識別子であり、DIDドキュメントに有効で確認されたハンドルが含まれていないアカウントは、理論的にはatprotoエコシステムに参加できます。ソフトウェアはそのようなアカウントに対してハンドルを表示しないか、関連するハンドルが無効であることを明示的に示すように注意する必要があります。

アカウントの公開**署名キー**は、`verificationMethod` 配列内にあります。`id`が `#atproto` で終わり、`controller`がDID自体と一致するオブジェクト内にあります。配列内の最初の有効なatproto署名キーが使用され、他のキーは無視されます。`type`フィールドは暗号曲線タイプを示し、`publicKeyMultibase`フィールドはmultibaseエンコーディングの公開鍵を示します。これらのフィールドの解析の詳細については以下を参照してください。

atprotoの機能には有効な署名キーが必要であり、DIDドキュメント内に有効なキーがないアカウントは壊れています。

アカウントの**PDSサービスネットワークの場所**は、`service` 配列内にあり、`id`が `#atproto_pds` で終わり、`type`が `AtprotoPersonalDataServer` と一致する必要があります。配列内の最初に一致するエントリを使用し、他のエントリは無視されます。`serviceEndpoint` フィールドにはサーバーのHTTPS URLが含まれている必要があります。これにはURIスキーム（`http`または`https`）、ホスト名、およびオプションのポート番号だけを含め、 "userinfo"、パスプレフィックス、または他のコンポーネントは含まれません。

atprotoのアカウント機能には動作するPDSが必要であり、DIDドキュメント内に有効なPDSの場所がないアカウントは壊れています。

有効なURLは、PDS自体が現在機能しているか、アカウントのためにコンテンツをホストしていることを意味するものではありません。アカウントの移行やサーバーのダウンタイム中には、PDSにアクセスできないウィンドウがあるかもしれませんが、これはすぐにアカウントが壊れて無効と見なされるべきではありません。

## 公開鍵の表現

atprotoの暗号システムに関する詳細は、[Cryptography](/specs/cryptography)に記載されており、公開鍵のバイトおよび文字列エンコーディングに関する詳細が述べられています。

`verificationMethod`内のDID文書の公開鍵（atproto署名鍵を含む）は、次のフィールドを持つオブジェクトとして表現されます：

- `id`（文字列、必須）：DIDの後に識別フラグメントが続きます。atproto署名鍵の場合、フラグメントに`#atproto`を使用します。
- `type`（文字列、必須）：固定の文字列`Multikey`
- `controller`（文字列、必須）：鍵を制御するDID。現行バージョンのatprotoでは、アカウントDID自体と一致する必要があります。
- `publicKeyMultibase`（文字列、必須）：公開鍵そのものを、multibase形式でエンコードしたもの（multicodecタイプインジケータおよび「圧縮」鍵バイトを含む）

`Multikey`の`publicKeyMultibase`形式は、`did:key`と同じエンコーディングスキームですが、`did:key:`接頭辞がない形式です。詳細については、[Cryptography](/specs/cryptography)を参照してください。

注意: DID `verificationMethod`セクションでP-256公開鍵を使用するためのW3Cの公式標準はまだ存在していませんが、`Multikey`標準はこの鍵タイプのエンコーディングが何であるべきかを明確にしています。

### 旧来の表現

一部の古いDID文書（`did:web`の文書にまだ存在する可能性があります）は、わずかに異なる鍵のエンコーディングと`verificationMethod`構文を持っていました。実装はこれらの古いDID文書を過渡期中にサポートする場合がありますが、将来的にはDIDの仕様準拠が必要となります。

atproto署名鍵の旧来の`verificationMethod`には以下が含まれていました：

- `id`（文字列、必須）：完全なDIDを含まない固定の文字列`#atproto`
- `type`（文字列、必須）：鍵の曲線タイプを識別する固定の名前
    - `p256`：`EcdsaSecp256r1VerificationKey2019`（「r」に注意）
    - `k256`：`EcdsaSecp256k1VerificationKey2019`（「k」に注意）
- `controller`（文字列、必須）：鍵を制御するDID。現行バージョンのatprotoでは、アカウントDID自体と一致する必要があります。
- `publicKeyMultibase`（文字列、必須）：公開鍵そのものを、multibase形式でエンコードしたもの（multicodecなし、および「非圧縮」鍵バイト）

注意: `EcdsaSecp256r1VerificationKey2019`タイプはW3Cの最終標準ではありません。

`EcdsaSecp256r1VerificationKey2019`の`verificationMethod`はW3Cの最終標準ではありません。`publicKeyMultibase`を使用したP-256公開鍵の表現に関してW3Cで標準化されるものに移行します。これは`Multikey`への移行を意味し、K-256表現も同様にその`type`に移行します。

この文脈でのmultibaseエンコーディングの概要：

- 完全な公開鍵バイトで始めます。 「圧縮」または「コンパクト」表現を使用しないでください（`did:key`または`Multikey`エンコーディングの場合とは異なります）
- 鍵の種類を示すmulticodec値をプレフィックスに追加しないでください
- 鍵バイトを`base58btc`でエンコードし、文字列を生成します
- プレフィックスとして文字`z`を追加して、multibaseを示し、他のmulticodecインジケータを含めません

逆のデコードプロセスは、曲線タイプをコンテキストとして使用します。

以下は、旧来の形式と現在の形式でエンコードされた単一の公開鍵の例です：

```
// K-256公開鍵の旧来のmultibaseエンコーディング
{
    "id": ...,
    "controller": ...,
    "type": "EcdsaSecp256k1VerificationKey2019",
    "publicKeyMultibase": "zQYEBzXeuTM9UR3rfvNag6L3RNAs5pQZyYPsomTsgQhsxLdEgCrPTLgFna8yqCnxPpNT7DBk6Ym3dgPKNu86vt9GR"
}

// 同じK-256公開鍵の推奨multibaseエンコーディング
{
    "id": ...,
    "controller": ...,
    "type": "Multikey",
    "publicKeyMultibase": "zQ3shXjHeiBuRCKmM36cuYnm7YEMzhGnCmCyW92sRJ9pribSF"
}
```

## 使用および実装ガイドライン

プロトコルの実装は、サポートされていないDIDメソッドに基づくコンテンツの処理に対して柔軟であるべきです。これは、プロトコルエコシステムの時間とともに徐々に進化させることを許可するために重要です。言い換えれば、実装は少なくとも「無効なDID構文」、「サポートされていないDIDメソッド」、および「サポートされているDIDメソッドだが特定のDID解決に失敗した」の異なるケースを区別すべきです。

プロトコルでは長いDIDがサポートされていますが、良いベストプラクティスは比較的短いDIDを使用し、64文字を超えるDIDは避けることです。

DIDは大文字と小文字を区別します。現在サポートされているメソッドは大文字と小文字を区別しませんが、プロトコルの実装は無効なケースのDIDを拒否するべきです。ユーザーが制御可能な入力を受け取る場合（例：パブリックURLパスコンポーネントの解析時やテキスト入力フィールドの場合）、ケースの正規化を試みることは許容されます。

## 可能性のある将来の変更

プロトコル構文レベルでDIDの最大長制限が縮小される可能性があります。私たちは、サポートを検討しているDIDメソッドが256文字より長い識別子を持つことはないと考えています。

「祝福された」DIDメソッドのセットが時間の経過とともに徐々に拡大する可能性が高いです。