---
title: HTTP API (XRPC)
summary: HTTPを介したクロスシステムのクエリと手続き
---

# HTTP API (XRPC)

atprotoのクライアントサーバーおよびサーバーサーバー要求のためのHTTP APIは、XRPCと呼ばれる一連の共通の慣例を使用しています。エンドポイントのパス名には、通常JSONコンテンツタイプを使用して、[Lexicon](/specs/lexicon)が要求および応答スキーマを指定するためのNSIDが含まれています。

## Lexicon HTTP エンドポイント

HTTPリクエストパスは常にトップレベルである必要があり、プレフィックス以下ではなく、`/xrpc/`で始まり、NSIDで続きます。NSIDは関連するLexiconの`id`フィールドにマップされます。

Lexiconで表現できる2つのリクエストタイプは「query」（HTTP GET）および「procedure」（HTTP POST）です。HTTP RESTのセマンティクスに従い、クエリ（GET）はキャッシュ可能で、リソースの状態を変更すべきではありません。手続きはキャッシュできず、状態を変更する可能性があります。

Lexiconの`params`（`parameters`フィールドの下）はHTTP URLクエリパラメータにマップされます。`params`タイプで指定されたものだけが、paramsに含まれることができます。同じ名前の複数のクエリパラメータを使用して、パラメータの配列を表すことができます。`boolean`パラメータをエンコードする場合は、`true`と`false`の文字列を使用する必要があります。文字列は引用符で囲まれていてはいけません。スキーマに`default`値が含まれている場合、一貫したキャッシュ動作を確保するために、すべてのリクエストに含めるべきです。

リクエストおよびレスポンスのボディコンテンツのタイプは、Lexiconで指定できます。スキーマは正確なMIMEタイプを要求することも、範囲を示すBlobパターンを指定することもできます（例：`image/*`）。

JSONボディスキーマは通常のatprotoデータモデルを使用してLexiconで指定されます。サーバーまたはクライアントによる完全な検証にはLexiconの知識が必要ですが、抽象データモデルに対する部分的な検証は常に可能です。

CORSサポートは奨励されますが、必須ではありません。

### エラーレスポンス

すべての不成功なレスポンスは、標準のエラーレスポンススキーマに従う必要があります。`Content-Type`は`application/json`である必要があり、ペイロードは以下のフィールドを持つJSONオブジェクトである必要があります：

- `error`（string、必須）：エラーのタイプ名（一般的なASCII定数、空白は不可）
- `message`（string、オプション）：エラーの説明、人間に適したもの

エラータイプは、エンドポイントのLexiconスキーマで定義されたエラー名にマップするべきです。これにより、クライアントソフトウェアによるより具体的なエラーハンドリングが可能になります。これは特に`400`、`500`、および`502`ステータスコードで推奨されます。

### Blobのアップロードとダウンロード

Blobsはいくぶん特殊なケースであり、任意のMIMEタイプを持つことができ、直接リポジトリに保存されず、したがって直接NSIDまたはLexiconに関連付けられません（ただし、最終的にはLexiconから参照されることがあります）。

Blobsを扱うための慣例は、クライアントが`com.atproto.repo.uploadBlob`エンドポイントを介してアップロードすることであり、これにはCIDとBlobに関する基本的なメタデータを含む`blob` JSONオブジェクトが返されます。クライアントはその後のリクエストでこの`blob`データを含めることができます（例：新しいレコードに含める）。MIMEタイプやファイルサイズなどの制約はこの2番目のステップでのみ検証されます。サーバーはアップロードステップでコンテンツタイプスニッフィングを実装し、提供された`Content-Type`ヘッダと異なるMIMEタイプを返すかもしれませんが、アップロードHTTPリクエストではそれでも`Content-Type`ヘッダが期待されています。

特定のアカウントのBlobsは、`com.atproto.sync.*` NSIDスペース内のエンドポイントを使用してリスト化およびダウンロードできます。これらのエンドポイントは、アップロード時の元のBlobに完全にアクセスできます。一般的なパターンは、アプリケーションが元のBlobとサムネイルまたはプレビューバージョンを別々のURL（例：CDN上）でミラーリングすることです。これにより、元のPDSの`getBlob`エンドポイントへの深いリンクの代わりに、アプリケーションが両方のバージョンにアクセスできます。

### カーソルとページネーション

Lexiconデザインの一般的なパターンは、ページネーションのために`cursor`パラメータを含めることです。クライアントは最初のリクエストに`cursor`パラメータを含めず、他のすべてのパラメータをリクエスト間で固定する必要があります。応答に`cursor`が含まれている場合、次の一連の応答を取得するには、その値をフォローオンに含めることができ、`cursor`が含まれなくなるまで続けると、結果セットの終わりが示されます。

## 認証

XRPCの現在の認証スキームは、JWTトークンを含むHTTP Bearer認証です（リフレッシュトークンを含む）。このスキームは拡張または置換される可能性があります。

すべてのエンドポイントが認証を必要とするわけではありませんが、どのエンドポイントが必要でないかを列挙する一貫した方法はまだありません。

初期ログインは`com.atproto.server.createSession`エンドポイントを使用し、パスワードとアカウント識別子（ハンドルまたは登録されたメールアドレスなど）を含みます。これには`refreshJwt`（および初期の`accessJwt`）が返されます。

ほとんどのリクエストはアクセスJWTを使用して認証するべきですが、これらのトークンの有効期限は短いです。数分ごとに、新しいアクセスJWTを取得するために`com.atproto.server.refreshSession`エンドポイントにアクセスJWTの代わりにリフレッシュJWTを使用できます。

JWT自体は不透明なトークンとして扱うべきです。

### アプリパスワード

アプリパスワードは、サードパーティのクライアントおよびWebアプリケーションにログインする際のセキュリティリスクを減少させるメカニズムです。アカウントはプライマリパスワードとは別にアプリパスワードを作成および取り消すことができます。これはプライマリパスワードと同じようにログインに使用されますが、クライアントアプリケーションにわずかに制限された権限を付与し、アカウントや認証設定の変更などの破壊的なアクションを防ぎます（アプリパスワード自体も含まれます）。

クライアントおよびアプリ自体は、アプリパスワードを使用するための特別な手順を実行する必要はありません。ほとんどのクライアントおよびアプリがログイン時にアプリパスワードの使用を思い出させるリマインダーを含めるのがベストプラクティスです。アプリパスワードは通常、`xxxx-xxxx-xxxx-xxxx`の形式を持ち、クライアントはこの形式に一致するかどうかを確認して、プライマリパスワードでの誤ってログインを防ぐことができます（プライマリパスワード自体がこの形式でない限り）。

### 管理者トークン（一時的な仕様）

一部の管理XRPCエンドポイントは管理者権限を持つユーザーとの認証が必要です。これに対する現在のスキームは、ユーザー「admin」とパスワードフィールドに固定トークンを使用したHTTPベーシック認証を使用することです。これにより、管理者リクエストには「admin」を超えるクライアントのアカウントまたはアイデンティティへのリンクがありません。

HTTPベーシック認証は、パスワード（この場合、固定された管理トークン）を`base64`エンコード（「標準」バージョン）し、ユーザー名とエンコードされたパスワードをコロン（`:`）で結合し、それを`Basic`（スペース付き）で前置した`Authorization`ヘッダに配置することによって機能します。

例えば、管理トークンが `secret-token` だった場合、ヘッダは以下のようになります：

```
Authorization: Basic admin:c2VjcmV0LXRva2Vu
```

この仕様で管理認証が必要なエンドポイントのセットは、現在の仕様では時折更新される可能性がありますが、現時点では以下を含みます：

- `com.atproto.admin.*`
- `com.atproto.server.createInviteCode`
- `com.atproto.server.createInviteCodes`

### サービス間認証（一時的な仕様）

このセクションでは、署名されたJWTを使用したサービス間認証のメカニズムを説明しています。これはサービス間認証の長期的な解決策ではなく、近い将来より堅牢なメカニズムに置き換えられる可能性があります。

現在のメカニズムは、アカウントのatproto署名キーによって署名された短寿命のJWTを使用するものです。受信サービスは、このキーをアカウントのDIDドキュメントと照らし合わせて署名の検証を行うことができます。

JWTのパラメータは以下の通りです：

- `alg`ヘッダフィールド：署名キータイプを示します（[Cryptography](/specs/cryptography)を参照）
    - `k256`キーには`ES256K`を使用
    - `p256`キーには`ES256`を使用
- `iss`ボディフィールド：リクエストが送信されているアカウントDID
- `aud`ボディフィールド：リクエストが送信されているサービスDID
- `exp`ボディフィールド：トークンの有効期限切れのUNIXタイムスタンプ（秒単位）。失効の実装がされていないため、60秒が適しています。
- JWT署名：アカウントDIDの署名キーを使用したbase64urlエンコードされた署名

署名は通常のJWTプロセスを使用して計算され、アカウントの署名キー（リポジトリのコミットに署名するために使用されるものと同じ）を使用します。Typescriptの擬似コードとしては、次のようになります：

```
const headerPayload = utf8ToBase64Url(jsonStringify(header)) + '.' + utf8ToBase64Url(jsonString(body))
const signature = hashAndSign(accountSigningKey, utf8Bytes(headerPayload))
const jwt = headerPayload + '.' + bytesToBase64Url(signature)
```

## HTTPヘッダーの概要

クライアントは次のヘッダーを使用することが期待されています：

`Content-Type`: リクエスト本文が存在する場合、このヘッダーを含め、コンテンツの種類を示す必要があります。

`Authorization`: 認証情報が含まれます。詳細はこの仕様の「認証」セクションを参照してください。

## HTTPステータスコードの概要

`200 OK`: リクエストが成功しました。応答本文（オプション）がある場合、`Content-Type`ヘッダーが必要です。

`400 Bad Request`: リクエストが無効であり、処理されませんでした。

`401 Unauthorized`: このエンドポイントには認証が必要です。`WWW-Authenticate`ヘッダーがあるべきです。

`403 Forbidden`: クライアントにはこのエンドポイントの許可がありません。

`404 Not Found`: リソースが見つからないことを示すことができます。これはまた、サーバーがatprotoをサポートしていないか、このエンドポイントをサポートしていないことを示すこともあります。クラリファイのために応答エラーメッセージ（またはその不在）を参照してください。

`413 Payload Too Large`: リクエスト本文が大きすぎます。可能であれば、複数の小さなリクエストに分割してください。

`429 Too Many Requests`: リソース制限が超過されました。クライアントは後退する必要があります。特定の後退時間を示す`Retry-After`ヘッダーがあるかもしれません。

`500 Internal Server Error`: 一般的な内部サービスエラー。クライアントは遅延後に再試行するかもしれません。

`501 Not Implemented`: 指定されたエンドポイントは既知ですが、実装されていません。クライアントは*再試行してはいけません*。特に、WebSocketsがリクエストされたがサーバーで実装されていない場合に返されます。

`502 Bad Gateway`, `503 Service Unavailable`, または `504 Gateway Timeout`: これらは通常、一時的または永続的なサービスの停止を示します。クライアントは遅延後に再試行することができます。

## 使用および実装のガイドライン

クライアントは、タイムアウト、限られた再試行、およびランダムな指数バックオフを実装することが奨励されています。これにより、断続的なダウンタイムが不可避な場合でも耐久性が向上し、苦しんでいるサーバーへの負荷が最小限に抑えられます。

サーバーはすべての`/xrpc/`パス接頭辞を持つリクエストに対してカスタムJSONエラーレスポンスを実装するべきですが、現実的には多くのサービスが一般的なロードバランサーまたはリバースプロキシのHTMLエラーページを返すかもしれません。クライアントは非JSONエラーレスポンスに対しても頑健であるべきです。

HTTPサーバーとクライアントライブラリは通常、URL全体のサイズ、クエリパラメータを含む制限を設けており、これらの制限はXRPCのパラメータの使用を制約しています。

PDSの実装は、Blobのアップロードを必要に応じて制限することができます。たとえば、グローバルな最大サイズまたは許可されたMIMEタイプの制約があるかもしれません。これらは、すべてのサポートされているLexiconsのBlob制約のスーパーセットであるべきです。

## セキュリティとプライバシーに関する考慮事項

インターネット上ではHTTPSのみを使用すべきです。

Blob内の個人情報（例：EXIFメタデータ）には注意が必要です。現在、感敏なEXIFメタデータをアップロード前にクライアントが取り除く責任があります。PDSが誤ってメタデータの漏洩を防ぐのを支援することも合理的であり、後述の将来の変更セクションを参照してください。

## 可能性のある将来の変更

認証システムは完全に見直される可能性があります。

Lexiconsは認証が必要かどうかを示すことができるべきです。

PDSの役割は一般的なゲートウェイとして正式化および拡張されるかもしれません。特定のXRPCエンドポイントを他のネットワークサービスにプロキシするための一般的なメカニズムが追加されるかもしれません。クエリとBlobの一般的なキャッシングが指定されるかもしれません。PDSによるサードパーティの応答の変更が明示的に許可されるかもしれません。

HTTPリダイレクトがサポートされているかどうかについての明示的な決定。

カーソルのページネーション動作は、カーソルが返されたが結果リストが空の場合や、カーソルの値が繰り返された場合について明確にされるべきです。

メディアBlobに埋め込まれた感敏なメタデータの誤発行を防ぐために、メタデータのストリッピングから除外するためのクエリパラメータがアップロードBlobエンドポイントに追加され、すべてのBlobに対してアップロードをブロックするかメタデータを自動的にストリッピングするかのデフォルトが指定されるかもしれません。
