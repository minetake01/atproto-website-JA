---
title: リポジトリ
summary: パブリックアカウントのコンテンツのための自己認証ストレージ
---

# リポジトリ

*より高いレベルの導入については、[Data Repositories Guide](../guides/data-repos)を参照してください。*

パブリックなatprotoコンテンツ（**records**）は、アカウントごとのリポジトリ（一般的には**repo**と略されることがよくあります）に保存されます。現在アクティブなすべてのrecordsはリポジトリに格納され、現在のリポジトリの内容は公開されていますが、コンテンツの削除とアカウントの削除は完全にサポートされています。

リポジトリのデータ構造はコンテンツアドレッシングされており（[Merkle-tree](https://en.wikipedia.org/wiki/Merkle_tree)）、リポジトリのコンテンツの変更（追加、削除、およびrecordsの更新など）ごとに新しいコミット`data`のハッシュ値（CID）が生成されます。コミットは暗号的に署名され、回転可能な署名キーを使用してコンテンツ全体または一部の再帰的な検証が可能です。

リポジトリとその内容はバイナリの[DAG-CBOR](https://ipld.io/docs/codecs/known/dag-cbor/)形式で規範的に格納され、[IPLD](https://ipld.io/docs/data-model/)データオブジェクトのグラフとして、コンテンツハッシュ（CIDリンク）でお互いを参照しています。大きなバイナリブロブは直接リポジトリに保存されませんが、ハッシュによって参照されます（[CID](https://github.com/multiformats/cid)）。これには画像やその他のメディアオブジェクトも含まれます。リポジトリは[CAR](https://ipld.io/specs/transport/car/carv1/)ファイルとしてエクスポートでき、オフラインバックアップ、アカウントの移行、またはその他の目的で使用できます。

atprotoフェデレーションアーキテクチャでは、アカウントのリポジトリの権威ある位置は関連するパーソナルデータサーバー（PDS）です。アカウントの現在のPDSの位置はDIDドキュメントで正確に示されています。

実際の使用では、個々のリポジトリには数十から数百万のrecordsが含まれることが期待されています。


## リポジトリデータ構造（v3）

これはリポジトリバイナリフォーマットのバージョン`3`の説明です。

バージョン`2`にはわずかに異なるコミットオブジェクトスキーマがありますが、ほとんどはバージョン`3`と互換性があります。

バージョン`1`には異なるMSTファンアウト構成があり、コミットとリポジトリメタデータの非互換なスキーマがありました。バージョン`1`は非推奨であり、このフォーマットのリポジトリはネットワークに存在せず、実装はそれをサポートする必要はありません。

高いレベルでは、リポジトリはキー/値マッピングであり、キーはパス名（文字列）で、値はrecords（DAG-CBORオブジェクト）です。

**Merkle Search Tree**（MST）はこのマッピングを格納するために使用されます。このコンテンツアドレッシングされた決定論的データ構造は、キーのソートされた順序でデータを格納します。ソートされたレコードパスを前提とすると、キールックアップ、キーレンジスキャン、およびアペンドには合理的に効率的です。MSTの一般的な特性については、次の学術論文で説明されています。

> Alex Auvolat、François Taïani。Merkle Search Trees: Efficient State-Based CRDTs in Open Networks. SRDS 2019 - 38th IEEE International Symposium on Reliable Distributed Systems、2019年10月、フランス、リヨン。pp.1-10、ff10.1109/SRDS.2019.00032（[pdf](https://inria.hal.science/hal-02303490/document)）

atprotoリポジトリで使用されるMSTの具体的な詳細は以下に説明されています。


### コミットオブジェクト

リポジトリ内のトップレベルデータオブジェクトは署名付きのコミットです。IPLDスキーマのフィールドは次のとおりです。

- `did`（文字列、必須）：リポジトリに関連するアカウントDID。厳密に正規化された形式であること（例：適切な場合は小文字）。
- `version`（整数、必須）：このリポフォーマットバージョンのための固定値`3`。
- `data`（CIDリンク、必須）：リポジトリコンテンツツリー構造（MST）のトップへのポインタ。
- `rev`（文字列、TID形式、必須）：リポのリビジョン、論理クロックとして使用されます。単調に増加する必要があります。現在のタイムスタンプをTIDとして使用することをお勧めします。将来の「未来」の（ある程度の許容範囲を超えた）`rev`値は無視され、処理されないようにします。
- `prev`（CIDリンク、オプション、null可能）：このリポジトリの以前のコミットオブジェクトへの（ハッシュによる）オプションのポインタ。履歴のチェーンを作成するために使用できますが、主に未使用です（v2の後方互換性のために含まれています）。
- `sig`（バイト配列、必須）：このコミットの暗号的な署名、生のバイトとして

UnsignedCommitデータオブジェクトには、`sig`以外のすべてのフィールドが含まれています。コミットに署名するプロセスは、すべてのデータフィールドを埋め、UnsignedCommitをDAG-CBORでシリアル化します。出力バイトは次にSHA-256でハッシュされ、バイナリハッシュ出力（16進エンコードなし）はアカウントの現在の「署名キー」を使用して署名されます。署名は、その他のデータフィールドと一緒にコミットオブジェクトに生のバイトとして格納されます。

コミット全体のCIDは、署名のないコミットオブジェクトをDAG-CBORとしてシリアル化することによって生成されます。下記の「祝福された」CIDフォーマットに関する注意事項を参照してください。特に、コミットオブジェクトへのリンクには`dag-cbor`マルチコーデックを使用するようにしてください。

なお、署名自体や署名付きのコミット自体には、使用されたキーの種類（曲線タイプ）や具体的な公開鍵が示されません。この情報はアカウントのDIDドキュメントから取得する必要があります。署名キーの回転がある場合、古いコミットの署名の検証があいまいになる可能性があります。最新のコミットは常に現在のDIDドキュメントを使用して検証できる必要があります。これは、署名キーが回転したときには新しいリポジトリコミットを作成する必要があることを意味します。このようなコミットは`data` CIDリンクを更新する必要はありません。


### MST構造

高いレベルでは、リポジトリMSTはキー/値マッピングであり、キーは空でないバイト配列で、値はrecordsへのCIDリンクです。このバイト列からCIDへのマッピングから、完全に再現可能なルートCIDハッシュ（またはコミットオブジェクトの`data`フィールド）があります。

ツリー構造の各ノードにはキー/CIDマッピングのセットと、他のサブツリーノードへのリンクが含まれています。エントリとリンクはキーでソートされ、リンクされたサブツリーのすべてのキー（再帰的に）は、対応するリンクの位置に対応する範囲に落ちます。ソート順は左から（辞書的に最初に）右に（辞書的に後に）です。各キーにはキー自体から導かれた**深さ**があり、これによってそれがどのサブツリーに終わるかが決まります。ツリーのトップノードには最も高い深さの値を持つすべてのキーが含まれています（小さなツリーの場合はすべて深さゼロになり、単一のノードになります）。ノード全体またはノード内の任意の2つのキーの間またはノード全体の左または右のリンクは、対応するキー範囲に落ちるサブツリーノードへのポインタを指します。

レコードがない空のリポジトリは、エントリの空配列を持つ単一のMSTノードとして表されます。これはツリーにキー（「エントリ」）を含まないまたはエントリを含むサブツリーを指さない空の葉ノードを含む唯一の状況です。ツリーのトップは、エントリを含まないノードであってはなりません。空の中間ノードは許可されますが、それはエントリを含むサブツリーを指さなければなりません。言い換えれば、空のノードはトップとツリーの底から刈り込まれなければならず、空の中間ノードは、サブツリーリンクが深さのレベルを1つスキップしないように保持されなければなりません。現在のキー/値コンテンツによらず、挿入と削除の履歴が現在のコンテンツにつながるようにMSTの全体の構造と形状が確定的である必要があります。

atproto MSTの実装では、使用されるハッシュアルゴリズムはSHA-256（バイナリ出力）で、2ビットのチャンクで「プレフィックスゼロ」を数え、ファンアウトは4です。キーの深さを計算するために：

- キー（バイト配列）をSHA-256でハッシュし、バイナリ出力で
- ハッシュの先頭のバイナリゼロの数を数え、2で割り、切り捨て
- 得られた正の整数がキーの深さです

以下は、ASCII文字列がバイト配列にマッピングされる例です。

- `2653ae71`：深さ "0"
- `blue`：深さ "1"
- `app.bsky.feed.post/454397e440ec`：深さ "4"
- `app.bsky.feed.post/9adeb165882c`：深さ "8"

リポジトリ内には多くのMSTノードがあるため、それらが効率的にバイナリで表現できるようにすることが重要です。ノード内では、キー（バイト配列）は共通の接頭辞を省略することによって圧縮され、各エントリは前のキーと共有するバイト数を示します。特定のノードにおける配列の最初のエントリは完全なキーを含み、共通の接頭辞の長さが0でなければなりません。このキーコンパクションはノード内部に内蔵されており、ツリー全体にまたがって拡張されません。コンパクションスキームは実装間でMST構造が一貫していることを確認するために強制されています。

ノードのIPLDスキーマのフィールドは次のとおりです。

- `l`（「left」、CIDリンク、オプション）：このノードよりも前のレベルと、このノードでのキーより前にすべてのキーをソートするサブツリーノードへのリンク
- `e`（「entries」、オブジェクトの配列、必須）：TreeEntryオブジェクトの順序付きリスト
    - `p`（「prefixlen」、整数、必須）：このノード内の前のTreeEntryと共有するバイト数（存在する場合）
    - `k`（「keysuffix」、バイト配列、必須）：このTreeEntryのキーの「prefixlen」が削除された後の残り部分
    - `v`（「value」、CIDリンク、必須）：このTreeEntryのキーの後にソートされるサブツリーノードへのリンク（「右」）

MSTデータ構造を解析する際には、キーの深さとソート順が検証されるべきです。これは特に信頼できない入力に対しては真実ですが、単に毎回検証するのが最も簡単です。ツリー構造のノードサイズや他のパラメータに関する追加のチェックも制限する必要があります。詳細については、このドキュメントの「セキュリティ考慮事項」セクションを参照してください。

### CID フォーマット

IPFS CID 仕様は非常に柔軟で、さまざまなハッシュタイプ、リンクされているコンテンツの種類を示すフィールド、およびさまざまな文字列エンコーディングオプションをサポートしています。これらの機能はリポジトリのフォーマットの進化を許可するために価値がありますが、実装間の相互運用性を最大限に確保するために、特定の「認定」されたCIDタイプのみが許可されています。

コミットオブジェクトとMSTノードオブジェクトのための認定されたフォーマットは、コミットオブジェクトへのリンク、MSTノード（または`data`、またはMST内部リンクとも呼ばれる）、またはレコード（またはMSTリーフノードからレコードへのリンク）の場合です：

- CIDv1
- Multibase: DAG-CBOR内のバイナリシリアライゼーション（またはJSONマッピングの場合は`base32`）
- Multicodec: `dag-cbor`（0x71）
- Multihash: 256ビットの`sha-256`（0x12）

リポジトリの文脈では、内容に基づいて全体のデータ構造が再現可能であることが望ましいため、許可されるCIDタイプは厳格に制約され、強制されます。非準拠の`prev`または`data`リンクを持つコミットオブジェクトは無効と見なされます。他のMSTノードオブジェクトへの非準拠のリンクを持つMSTノードオブジェクトも無効と見なされ、全体のMSTデータ構造も無効とされます。

"MST"からレコードへの「リーフ」リンクの処理では、実装はこれらのマッピングに使用されるCIDリンクを正規化するのではなく、そのまま保持することが求められます。新しいCIDリンクをレコードに生成する際には、実装はCIDの認定されたフォーマットに厳密に従うべきです。

## CARファイルのシリアライゼーション

IPLDデータを格納するための標準ファイル形式はContent Addressable aRchives（CAR）です。atprotoリポジトリの標準リポジトリエクスポートフォーマットは[CAR v1](https://ipld.io/specs/transport/car/carv1/)であり、ファイルのサフィックスは`.car`で、MIMEタイプは`application/vnd.ipld.car`です。

CARv1フォーマットは非常にシンプルです。小さなメタデータヘッダー（1つまたは複数の「ルート」CIDリンクを示すことができます）が含まれ、その後には各々がIPLDオブジェクトであるバイナリ「ブロック」のシリーズが続きます。atprotoリポジトリの文脈では：

- CARの`roots`メタデータ配列の最初の要素は、最も関連性のあるコミットオブジェクトのCIDである必要があります。一般的なエクスポートの場合、これは現在の（最新の）コミットです。`roots`配列には他にも（現時点では）未定義の意味や順序があるかもしれません
- フルエクスポートの場合、指定されたコミットの完全なリポジトリ構造が含まれている必要があります。これにはすべてのレコードとすべてのMSTノードが含まれます
- CARファイル内のブロックの順序は現在定義されておらず、制限されていません。実装には「推奨される」順序があるかもしれませんが、予期しない順序に対して寛容であるべきです
- CARファイルにはレコードを含む追加のブロックが含まれるかもしれません

CARファイルをインポートする際には、存在するかもしれないダングリングCID参照があることに注意してください。たとえば、リポジトリには他のリポジトリのブロブやレコードへのCIDリンクが含まれ、これらのブロブやリファレンスに対応するIPLDブロックはCARファイルにおそらく含まれていないでしょう。

CARv1仕様は同じファイル内で同じブロックが複数回現れることについて無関心です（「重複ブロック」）。実装はブロックの重複および非重複に堅牢であるべきであり、不要またはリンクされていないブロックを無視するべきです。

## セキュリティに関する考慮事項

リポジトリは信頼できない入力です：アカウントはリポジトリの内容に完全な制御権を持ち、PDSインスタンスはバイナリエンコーディングに完全な制御権を持っています。敵対的なアクターや偶発的な状況（例：破損したデータまたはバグのある実装）からのサービス妨害ベクトルに対処することが重要です。

CBORデコーディングでは一般的な予防措置が必要です：最大シリアル化オブジェクトサイズ、ネストされたフィールドの最大再帰深度、デシリアライズされたデータの最大メモリ予算など。一部のCBORライブラリにはこれらの予防措置がデフォルトで含まれていますが、他のものは含まれていません。

MSTデータ構造の効率は、キーハッシュが比較的ランダムに分散していることに依存しています。アカウントはレコードキーを制御できるため、特定の深さとソーティング順序を持つレコードキーのセットを採掘でき、非効率なツリー形状を引き起こし、大きなストレージオーバーヘッドとフェデレーションストリームのコンテキストでのネットワークの拡大を引き起こす可能性があります。これらの攻撃に対抗するために、実装はノードごとのTreeEntriesの数を統計的にありえない最大長に制限するべきです。リポジトリ全体の深さまたは他のパラメータを制限することも必要かもしれません。 

CARファイルをインポートする際には、リポジトリ構造の完全性を検証する必要があります。CAR構造には追加の無関係なブロックが含まれる可能性があります。CARコンテンツを直接バックエンドブロックストレージに注入する際には、参照されていないブロックにリソースが無駄にならないように注意する必要があります。CARのインポートからのクロスアカウントの混入の問題も発生する可能性があります。たとえば、無関係なアカウントからのCARインポートにより、以前に削除されたレコードが再び現れるかもしれません。

## 可能性のある将来の変更

同じレコードの複数のバージョンを（パスで）保存するためのオプションのリポ内メカニズムが実装される可能性があります。たとえば、CID、タイムスタンプ、または単調に増加するバージョン整数を示すための追加のパスフィールドを追加するなどです。

各レコードに関連するメタデータを保存するためのメカニズムが検討されています。たとえば、一般的なラベル、再利用権利、またはハッシュタグのメタデータなどです。これにより、レコード自体を変更せずにメタデータを変更でき、いくつかのメタデータがレキシコン全体で共通化される可能性があります。

リポのパス制限が異なる方法で緩和されるかもしれません。これには少ないまたは追加のパスセグメント、非ASCII文字を含むより多くの許可される文字などが含まれます。パスは常に有効なUnicode文字列であり、UTF-8エンコーディングによってMSTキー（バイト配列）にマップされます。

全体的なatproto仕様レベルでは、時間の経過とともに追加の「認定」された暗号アルゴリズムが追加される可能性があります。同様に、レコードやブロブを参照するための追加のCIDフォーマットも追加されるかもしれません。内部CIDフォーマットの変更にはリポフォーマットバージョンの変更が必要です。

リポジトリCARエクスポートにはリンクされた「ブロブ」（大きなバイナリファイル）が含まれる可能性があります。これがデフォルトになるか、設定可能なオプションになるか、または別のブロブエクスポートメカニズムが選択される可能性があります（たとえば`.tar`または`.zip`エクスポート）。

レコードの内容は将来的にDAG-CBOR以外のものになるかもしれません。これはおそらくリポフォーマットバージョンの変更になるでしょう。なお、他のデータ形式をDAG-CBORラッパーで効率的にラップすることも可能です（バイト配列フィールドを介したもの）、または任意の形式のブロブにリンクする小さなDAG-CBORレコード型を持つこともできます。

リポジトリCARエクスポートは、指定されたブロックの順序を指定するための最適化を含むCARv2ファイルフォーマットがあるかもしれません。

レコードの内容は将来的にDAG-CBOR以外のものになる可能性があります。これはおそらくリポジトリの形式のバージョンアップになるでしょう。なお、他のデータ形式を効率的にDAG-CBORラッパーで包むことも可能です（バイト配列フィールドを介して）、または小さなDAG-CBORレコードタイプを持ち、任意の形式のブロブにリンクすることもできます。

リポジトリCARエクスポートは、指定された優先ブロックの順序付けスキームで終了する可能性があります。

一部の使用ケースに最適化されたCARv2ファイルフォーマットが、ある形式で採用されるかもしれません。

コミットおよびMSTノードオブジェクトにオプショナルなフィールドを追加することは、リポジトリ形式のバージョン変更につながるかもしれませんし、つながらないかもしれません。MSTファンアウトの変更、または現在のMSTフィールズへの変更は、完全なリポジトリバージョンの変更になります。
