---
title: データモデル
summary: レコードとメッセージのための一貫したデータエンコーディング。
---

# データモデル

atprotoのレコードとメッセージは、一貫した方法で格納、転送、エンコード、および認証されます。コアの「データモデル」は、[Interplanetary Linked Data (IPLD)](https://ipld.io/docs/data-model/)に基づいており、これはIPFSエコシステムからのハッシュリンクデータ構造の仕様です。

データが認証（署名）、参照（コンテンツハッシュによるリンク）、または効率的に保存される必要がある場合、それはConcise Binary Object Representation (CBOR)でエンコードされます。CBORは、おおよそJSONに基づくIETF標準です。IPLDは、CBORの正規化されたサブセットである**DAG-CBOR**を指定しており、これがatprotoで使用されているものです。

IPLDはまた、JSONの対応する一連の規約も指定していますが、atprotoではJSONデータをエンコードする際には異なる一連の規約を使用しています。

atprotoのスキーマ定義言語は[Lexicon](/specs/lexicon)です。IPLDスキーマ言語は使用されていません。他のより低レベルなデータ構造、例えば[repository](/specs/repository)の内部などは、Lexiconsでは指定されていませんが、同じデータモデルとエンコーディングを使用しています。

IPLDでは、異なるデータの断片を**ノード**と呼び、バイナリ（DAG-CBOR）でエンコードすると**ブロック**になります。ノードには内部にネストされた構造（マップやリスト）がある場合があります。ノードは通常のJSONと同様に、文字列のURLやURIで互いを参照することができます。IPLDでは、ハッシュによって強力に互いを参照することもでき、これはIPLDで**リンク**と呼ばれています。リンクされたノードのセットは、[Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree)や[Directed Acyclical Graphs (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph)などのより高次のデータ構造を形成することができます。リンクはまた、任意のバイナリデータ（blob）を参照することもできます。

URLとは異なり、ハッシュ参照（リンク）はコンテンツが見つかる特定のネットワーク場所をエンコードしない。場所とアクセスメカニズムはプロトコルレベルのコンテキストから推論される必要があります。ハッシュ参照は「自己証明的」であるという特性があり、返されたデータをリンクハッシュと照合できます。これにより、信頼できないパーティから来た場合でも、コンテンツを再配布し、コピーを信頼できるようになります。

リンクは[IPFS Content Identifiers](https://docs.ipfs.tech/concepts/content-addressing/#identifier-formats) (CIDs)としてエンコードされ、バイナリと文字列の表現があります。CIDsには、ノード（DAG-CBOR）または任意のバイナリデータにリンクするかを示すメタデータコードが含まれています。atprotoでのCIDsの使用に関するいくつかの追加の制約については以下で説明されています。

atprotoでは、オブジェクトノードにはしばしば`$type`という文字列フィールドが含まれ、それがLexiconスキーマを指定しています。データは主に自己記述的であり、スキーマに依存せずに処理できます（デコードおよび再エンコードを含む）。ただし、スキーマが手元にないか事前に知られていない場合、データは完全に検証できません。

## データタイプ

| Lexicon タイプ | IPLD タイプ | JSON                 | CBOR                    | ノート                  |
| ---           | ---       | ---                  | ---                     | ---                     |
| `null`        | null      | Null                 | 特殊値 (major 7)       |                         |
| `boolean`     | boolean   | Boolean              | 特殊値 (major 7)       |                         |
| `integer`     | integer   | Number               | Integer (majors 0,1)    | サインあり、64ビット     |
| `string`      | string    | String               | UTF-8 String (major 3)  | Unicode, UTF-8          |
| -             | float     | Number               | 特殊 (major 7)          | atprotoでは許可されていません |
| `bytes`       | bytes     | `$bytes` オブジェクト | Byte String (major 2)   |                         |
| `cid-link`    | link      | `$link` オブジェクト  |

 CID (tag 42)            | CID                     |
| `array`       | list      | Array                | Array (major 4)         |                         |
| `object`      | map       | Object               | Map (major 5)           | キーは常に文字列です       |
| `blob`        | -         | `$type: blob` オブジェクト | `$type: blob` マップ |                         |

`blob`はファイルへの参照（例: 画像）のためのものです。基本的なメタデータ（MIMEタイプとサイズ（バイト単位））も含まれています。

デフォルトの型との互換性を確保するために、JavaScriptと整合するためには`integer`は53ビットの精度に制限すべきです。JSONの数値は任意の桁数を持つことができますが、JavaScriptを無視しても`integer`は64ビットに制限されています。

Lexiconsは個々のフィールドに追加の検証制約を含めることができます。たとえば、整数は最大および最小値を持つことができます。これらの追加の制約を有効にするには、関連するLexiconスキーマにアクセスする必要がありますが、抽象的な意味でatprotoデータモデルに対して自由な形式のJSONまたはCBORを検証する概念があります。たとえば、`$bytes`オブジェクトにベース64エンコードされた文字列ではなくブール値が含まれるJSONオブジェクトは有効なJSONかもしれませんが、atprotoデータモデルには決して有効ではありません。

Lexicon文字列フィールドには、検証のために関連付けられた`format`タイプ情報が追加できますが、他の検証制約と同様に、この情報はLexicon自体がないと利用できません。

### NullableとFalse-y

atprotoデータモデルでは、明示的にマップフィールドを`null`に設定することと、フィールドを含まないこととのセマンティックな違いがあります。JSONとCBORの両方にこの違いがあります。

また、`false`（ブール）、`0`（整数）、空のリスト、または空のオブジェクトなどの「false-y」な値とは異なり、`null`または欠落したフィールドも区別されます。

### なぜFloatがないのか？

IPLD、CBOR、およびJSONはすべてネイティブで浮動小数点数をサポートしていますが、なぜatprotoはそれらを明示的に無効にするのでしょうか？

IPLD仕様は、浮動小数点数をコンテンツアドレッシング可能な世界で取り扱う際の複雑さとシャープエッジについて説明しています。要するに、マシンネイティブ形式に逆シリアル化してから後で再エンコードすることが常に一貫していないということです。これは特殊な値や特殊なケースだけでなく、一般的でないアーキテクチャでも「通常」の浮動小数点値に当てはまる可能性があります。

将来的には、浮動小数点数を信頼性のあるラウンドトリップエンコーディングを確実にするためのルールを考案することができるかもしれませんが、現時点では浮動小数点数は無効にしています。

整数では浮動小数点数を代替できないユースケースがある場合は、浮動小数点数を文字列またはバイトとしてエンコードすることをお勧めします。これにより、安全なデフォルトのラウンドトリップ表現が得られます。

## `blob` タイプ

"blobs"（任意のファイル）への参照は、atprotoで一貫した形式を持ち、スキーマにアクセスせずに検出および処理することができます。つまり、スキーマを知らなくてもノードを解析し、blobへの参照を抽出することができます。

Blobノードは次のフィールドを持つマップです：

- `$type`（文字列、必須）：固定値`blob`。これは有効なNSIDではありません。
- `ref`（link、必須）：blobへのCID参照。JSONでは通常のように`$link`オブジェクトとしてエンコードされます。
- `mimeType`（文字列、必須、空でない）：blobのコンテンツタイプ。不明な場合は`application/octet-stream`。
- `size`（整数、必須、正、非ゼロ）：バイト単位でのblobの長さ

また、非推奨のレガシーなblob形式もあり、依然としてこの形式のblob参照を含む一部のレコードが存在しています：

- `cid`（文字列、必須）：リンク形式ではなく、文字列形式のCID
- `mimeType`（文字列、必須、空でない）：上記の`mimeType`と同じ

なお、レガシーフォーマットには`$type`がなく、既知のLexiconsに対してのみ解析できます。実装では古いフォーマットに遭遇したときにエラーをスローしてはならず、それらを書き込まないようにし、部分的にしかサポートしなくても構いません。

## JSON表現

atprotoはDAG-JSONを直接使用せず、独自のJSON表記規則を使用しています。主な動機はHTTP APIでの`link`および`bytes`のためのより慣用的で人間にとって読みやすい表現を持つことでした。DAG-JSON仕様自体は、デバッグおよび開発環境向けに主に向けられていると述べており、`/`をフィールドキーとして使用することが開発者にとって混乱のもとになると判断されました。

JSONをatprotoで使用する場合、キーのソートなどの正規化は必要ありません。バイト再現可能な表現としてはDAG-CBORのみが使用されます。

コアおよび複合型のほとんどのエンコーディングは直感的であり、`link`および`bytes`のみが特別な取り扱いを必要とします。

### `link`

IPLDリンクのJSONエンコーディングは、単一のキー`$link`と、文字列エンコードされたCIDを値とするオブジェクトです。

たとえば、タイプが`link`のフィールド `"exampleLink"` 1 つだけを持つノードは、以下のようにJSONでエンコードされます：

```
{
  "exampleLink": {
    "$link": "bafyreidfayvfuwqa7qlnopdjiqrxzs6blmoeu4rujcjtnci5beludirz2a"
  }
}

```

比較のために、これはDAG-JSONエンコーディングに非常に似ていますが、キー名が`$link`に置き換わっています（単一文字のスラッシュではなく）。

### `bytes`

バイトのJSONエンコーディングは、単一のキー`$bytes`と、base64でエンコードされたバイトを含む文字列値のオブジェクトです。このスキームは[RFC-4648、セクション4](https://datatracker.ietf.org/doc/html/rfc4648#section-4)で指定されているもので、「シンプルなbase64」として頻繁に参照されます。このスキームはURLセーフではなく、`=`のパディングはオプションです。

たとえば、タイプが`bytes`のフィールド `"exampleBytes"` 1 つだけを持つノードは、以下のようにJSONで表されます：

```
{
  "exampleBytes": {
    "$bytes": "nFERjvLLiw9qm45JrqH9QTzyC2Lu1Xb4ne6+sBrCzI0"
  }
}

```

比較のために、DAG-JSONエンコーディングは2つのネストされたオブジェクトを持ち、外側のキーは`/`（単一文字のスラッシュ）、内側のキーは`bytes`で、同じbase64エンコーディングです。

## リンクとCIDのフォーマット

[IPFS CID仕様](https://github.com/multiformats/cid)は非常に柔軟です。さまざまなハッシュタイプ、リンクされているコンテンツの「タイプ」を示すフィールド、およびさまざまな文字列エンコーディングオプションをサポートしています。これらの機能は時間の経過とともに進化するために貴重ですが、実装間の相互運用性を最大化するためには、特定の「祝福された」CIDタイプのみが許可されます。

atprotoのCIDのための祝福されたフォーマットは次のとおりです：

- CIDv1
- multibase：DAG-CBOR `link`フィールドおよび文字列エンコーディングのためのバイナリシリアライゼーションで`base32`を使用
- multicodec：データオブジェクトへのリンクのために`dag-cbor`（0x71）、blobへのリンクのために`raw`（0x55）を使用
- multihash：256ビットのSHA-256（0x12）が推奨されています

SHA-256の使用は、リポジトリMSTノードなど、一部の文脈での安定した要件です。他の文脈では、メディアブロブの参照など、時間の経過と共に進化する「祝福された」ハッシュタイプのセットがある可能性があります。プロトコルの柔軟性と（改良されたハッシュを採用し、弱いものを削除するためのもの）と、プロトコルの実装のエコシステム全体で広範で一貫した相互運用性を確保する必要があります。

atprotoオブジェクトでCIDハッシュ参照を含めるためのいくつかの方法があります：

- `link` フィールドタイプ（Lexiconタイプ `cid-link`）。DAG-CBORでは、バイナリCID（multibaseタイプ0x00）をCBORタグ42のバイト列としてエンコードします。JSONでは、`$link` オブジェクトとしてエンコードされます（上記参照）。
- `string` フィールドタイプ、Lexicon文字列フォーマット `cid` を使用。DAG-CBORおよびJSONでは、単純な文字列としてエンコードされます。
- `string` フィールドタイプ、Lexicon文字列フォーマット `uri` を使用し、URIスキームが `ipld://` の場合。

## 使用および実装ガイドライン

非推奨の/レガシーな「blob」フォーマットで作業する場合、通常の「blob」参照と同じ内部表現で保存することをお勧めしますが、`size` をゼロまたは負の値に設定します。このフィールドは、正しいラウンドトリップ動作を確認し、通常のオブジェクトフォーマットでゼロまたは負の `size` 値をエンコードしないようにするために、再シリアル化時に確認する必要があります。

## セキュリティとプライバシーに関する考慮事項

信頼できないCBORコンテンツを解析する際には、多くのリソース消費攻撃が可能です。巨大な割り当て、深いネスト、無効な参照などに対して自動的に保護するライブラリの使用が推奨されています。これは特に、CやC++などのメモリセーフティが弱い言語で実装されたライブラリにとって重要です。高水準の言語はしばしば、より低水準の言語で書かれたパーサーをラップしています。

## 可能性のある将来の変更

浮動小数点数はある形式でサポートされるかもしれません。

すべての既知のレコードとリポジトリが書き直せる場合、古い「blob」フォーマットは完全に削除されるかもしれません。

追加のハッシュタイプは「祝福された」CID構成のセットに含まれる可能性があります。